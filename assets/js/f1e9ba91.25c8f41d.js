"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[6836],{4137:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),d=r,h=u["".concat(c,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3880:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return u}});var a=n(7462),r=n(3366),o=(n(7294),n(4137)),i=["components"],s={title:"The E4X approach to XML processing",sidebar_position:3},c=void 0,l={unversionedId:"development/core-actionscript-classes/working-with-xml/e4x-approach-to-xml-processing",id:"development/core-actionscript-classes/working-with-xml/e4x-approach-to-xml-processing",isDocsHomePage:!1,title:"The E4X approach to XML processing",description:"The ECMAScript for XML specification defines a set of classes and functionality for working with XML data. These classes and functionality are known collectively as E4X. ActionScript 3.0 includes the following E4X classes: XML, XMLList, QName, and Namespace.",source:"@site/docs/development/core-actionscript-classes/working-with-xml/e4x-approach-to-xml-processing.md",sourceDirName:"development/core-actionscript-classes/working-with-xml",slug:"/development/core-actionscript-classes/working-with-xml/e4x-approach-to-xml-processing",permalink:"/docs/development/core-actionscript-classes/working-with-xml/e4x-approach-to-xml-processing",editUrl:"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/core-actionscript-classes/working-with-xml/e4x-approach-to-xml-processing.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"The E4X approach to XML processing",sidebar_position:3},sidebar:"mainSidebar",previous:{title:"Basics of XML",permalink:"/docs/development/core-actionscript-classes/working-with-xml/basics-of-xml"},next:{title:"XML objects",permalink:"/docs/development/core-actionscript-classes/working-with-xml/xml-objects"}},p=[],m={toc:p};function u(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The ECMAScript for XML specification defines a set of classes and functionality for working with XML data. These classes and functionality are known collectively as E4X. ActionScript 3.0 includes the following E4X classes: XML, XMLList, QName, and Namespace."),(0,o.kt)("p",null,"The methods, properties, and operators of the E4X classes are designed with the following goals:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Simplicity - Where possible, E4X makes it easier to write and understand code for working with XML data."),(0,o.kt)("li",{parentName:"ul"},"Consistency - The methods and reasoning behind E4X are internally consistent and consistent with other parts of ActionScript."),(0,o.kt)("li",{parentName:"ul"},"Familiarity - You manipulate XML data with well-known operators, such as the dot ( . ) operator.")),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"There is a different XML class in ActionScript 2.0. In ActionScript 3.0 that class has been renamed as ",(0,o.kt)("inlineCode",{parentName:"p"},"XMLDocument"),", so that the name does not conflict with the ActionScript 3.0 XML class that is part of E4X. In ActionScript 3.0, the legacy classes\u2014XMLDocument, XMLNode, XMLParser, and XMLTag\u2014are included in the flash.xml package primarily for legacy support. The new E4X classes are core classes; you need not import a package to use them. For details on the legacy ActionScript 2.0 XML classes, see the ",(0,o.kt)("a",{parentName:"p",href:"http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/xml/package-detail.html"},"flash.xml package")," in the ",(0,o.kt)("a",{parentName:"p",href:"http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/index.html"},"ActionScript 3.0 Reference for the Adobe Flash Platform")," ."))),(0,o.kt)("p",null,"Here is an example of manipulating data with E4X:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},"var myXML:XML =\n    <order>\n        <item id='1'>\n            <menuName>burger</menuName>\n            <price>3.95</price>\n        </item>\n        <item id='2'>\n            <menuName>fries</menuName>\n            <price>1.45</price>\n        </item>\n    </order>\n")),(0,o.kt)("p",null,"Often, your application will load XML data from an external source, such as a web service or a RSS feed. However, for clarity, the code examples provided here assign XML data as literals."),(0,o.kt)("p",null,"As the following code shows, E4X includes some intuitive operators, such as the dot ( . ) and attribute identifier ( @ ) operators, for accessing properties and attributes in the XML:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},'trace(myXML.item[0].menuName); // Output: burger\ntrace(myXML.item.(@id==2).menuName); // Output: fries\ntrace(myXML.item.(menuName=="burger").price); // Output: 3.95\n')),(0,o.kt)("p",null,"Use the appendChild() method to assign a new child node to the XML, as the following snippet shows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},'var newItem:XML =\n    <item id="3">\n        <menuName>medium cola</menuName>\n        <price>1.25</price>\n    </item>\n\nmyXML.appendChild(newItem);\n')),(0,o.kt)("p",null,"Use the ",(0,o.kt)("inlineCode",{parentName:"p"},"@")," and ",(0,o.kt)("inlineCode",{parentName:"p"},".")," operators not only to read data, but also to assign data, as in the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},'myXML.item[0].menuName="regular burger";\nmyXML.item[1].menuName="small fries";\nmyXML.item[2].menuName="medium cola";\n\nmyXML.item.(menuName=="regular burger").@quantity = "2";\nmyXML.item.(menuName=="small fries").@quantity = "2";\nmyXML.item.(menuName=="medium cola").@quantity = "2";\n')),(0,o.kt)("p",null,"Use a for loop to iterate through nodes of the XML, as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-actionscript"},'var total:Number = 0;\nfor each (var property:XML in myXML.item)\n{\n    var q:int = Number(property.@quantity);\n    var p:Number = Number(property.price);\n    var itemTotal:Number = q \\* p;\n    total += itemTotal;\n    trace(q + " " + property.menuName + " $" + itemTotal.toFixed(2))\n}\ntrace("Total: $", total.toFixed(2));\n')))}u.isMDXComponent=!0}}]);